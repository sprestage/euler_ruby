#!/usr/bin/env ruby
###
# Each new term in the Fibonacci sequence is generated by adding the previous
# two terms. By starting with 1 and 2, the first 10 terms will be:
#
# 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...
#
# By considering the terms in the Fibonacci sequence whose values do not exceed
# four million, find the sum of the even-valued terms.
#
###

### Very concise recursive fibonacci method.  Consider revising to use this.
# Credit for this solution goes to Aja Hammerly's "A World Without Assignment"
# talk at the MountainWest RubyConf 2014.  On second consideration, implementation,
# and testing, it turns out that resursion takes much longer ~10sec than the
# iterative (looped) way which takes ~0.1sec.  Leaving all code here for further
# reference.  -sprestage 6/3/14
def fib(n)
  case n
  when 0
    0
  when 1
    1
  else fib(n-1) + fib(n-2)
  end
end

def findXthFibonacciNumber(xth_term)
  if xth_term == 0
    return 0
  end
  if xth_term == 1
    return 1
  end
  if xth_term == 2
    return 1
  end
  fib_n_minus_two = 1
  fib_n_minus_one = 1
  fib_n = 0
  3.upto(xth_term) do |x|
    fib_n = fib_n_minus_two + fib_n_minus_one
    fib_n_minus_two = fib_n_minus_one
    fib_n_minus_one = fib_n
  end
  return fib_n
end

fib_sum = 0
fib_n_minus_two = 1
fib_n_minus_one = 1
fib_n = 0

puts

### First solution is the quickest.
until fib_n > 4_000_000
  fib_n = fib_n_minus_one + fib_n_minus_two
  fib_n_minus_two = fib_n_minus_one
  fib_n_minus_one = fib_n
  if fib_n_minus_two % 2 == 0
    fib_sum += fib_n_minus_two
  end
end

the_end = 0
n = 1

### Second solution is very slow.
until the_end > 4_000_000
  the_end = fib(n)
  n += 1
  puts the_end
end

the_end = 0
n = 1

### Third solution is also pretty quick.
until the_end > 4_000_000
  the_end = findXthFibonacciNumber(n)
  n += 1
  puts the_end
end

puts " = #{fib_sum}"
